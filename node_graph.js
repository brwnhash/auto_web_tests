

/*Node is created by Pre-Event , Node has State ,at first its in initial State
 * State has actions ,Actions will cause Node to have transitions ,or create
 *  a Event for other Nodes.
 Node has initial state and actions does transitions to different states 
 Actions are connected to state ,as in a given state,actions can
 vary , and action further leads to a new State ,either in same
 node of new Node. 
 */


const { Action, MOUSE_DEFAULT_ACTIONS,
    MOUSE_ACTIONS_ORDER_MAP, MOUSE_ACT_TYPE,
    MOUSE_ACTIONS } = require('./dom_actions');
const { ListMap } = require('./common');
const objHash = require('object-hash');

const StateTypes = {
    INIT: "INIT",
    TRANSIT: "TRANSIT",
    TERMINATE:"TERMINATE"
}

class State {

    constructor(node, dims, props, idx, pre_event, id,type) {
        this.node = node;
        this.dims = dims;
        this.props = props;
        this.idx = idx;
        this.state_type = type;
        this.pre_events = [pre_event];
        this.actions = [];
        this.action_names = []; //used to avoid same action names in list
        this.id = id;
        this.visit_idx = 0;
        this.trace = null;

    }

    addPreEvent(event) {
        let existing = this.pre_events.filter(ev => ev.id == event.id);
        if (existing.length == 0) {
            this.pre_events.push(event);
            return true;
        }
        return false;
    }
    //trace we try to find shortest path.given value set to true
    //we dont allow other node to go through that path
    backTrace() {
        if (this.trace == null) {
            this.trace = true;
            return true;
        }
        return false;
    }
    forwardTrace() {
        this.trace = null;
    }


    addListenerns(listeners) {
        let path_list = [];
        listeners.forEach(listener => {
            let seq = 0, act_type = '';
            if (MOUSE_ACTIONS.includes(listener['type'])) {
                seq = MOUSE_ACTIONS_ORDER_MAP[listener['type']];
                act_type = MOUSE_ACT_TYPE;
            }

            let data = {
                'path': this.node.path, 'type': 'action', 'seq': seq,
                'sub_type': listener['type'], 'data': listener, 'act_type': act_type
            };
            let act_idx = listener ?.['act_idx'] || 1;
            let act = new Action(data, this, act_idx);
            this.addAction(act);

        });

    }

    addAction(act) {
        if (this.action_names.includes(act.name)) return;
        this.actions.push(act);
        this.action_names.push(act.name);
    }
    sortActions() {
        this.actions = this.actions.sort((a, b) => {
            let elm_a = a.data_obj.seq.order, elm_b = b.data_obj.seq.order
            if (elm_a == elm_b) return 0;
            return elm_a < elm_b ? -1 : 1; //-1 to left and 1 to right
        });
    }
}

// Every Node has a initial state ,add that whenever node is created

class Node {
    constructor(node_graph, path, parent, dims, props, pre_event,id) {
        /* x_path :location on dom
         * pre_events:list of events that can create this node
         * */
        this.x_path = path;
        this.node_graph = node_graph;
        this.dims = dims;
        this.props = this.props;
        this.pre_events = [pre_event];// event that causes node to be constructed
        this.parent = parent;
        this.path = path;
        this.node_type = null;
        this.init_state = null;
        this.is_active = true;
        this.node_id = id;// should be generated by props
        this.state_dict = new Map();
        this.curr_state = null;
        this.addNewState(dims, props, pre_event, StateTypes.INIT);
        this.children = [];
        this.depth = this.parent == null ? 0 : this.parent.depth + 1;
    }

    addNewState(dims, props, pre_event,state_type) {
        /* its possible that there is transition to existing state.
         * you should check that in that case dont create new state
         * 
         */
        let id = props ? objHash({ ...dims, ...props }, { respectType: false }) : null;
        let state = null;
        //if (this.state_dict.size > 0) {
        //    let old_state = this.state_dict.values().next().value;
        //    for (let k in old_state.props) {
        //        if (old_state.props[k] != props[k]) {
        //            console.log('props not same for ', k, old_state.props[k], props[k]);
        //        }
        //    }
        //}
        //if same state reached by different event..otherwise just increment visit idx
        if (this.state_dict.has(id)) {
            state = this.state_dict.get(id);
            let ev_status = state.addPreEvent(pre_event);
            if (ev_status) this.node_graph.action_state_dict.set(pre_event.id, state);
            state.visit_idx += 1;
            this.curr_state = state;
            return { 'state_transit': false, 'new_event': ev_status };
        }
        else {
            state = new State(this, dims, props, this.state_dict.size, pre_event, id,state_type);
            this.state_dict.set(id, state);
            state.addPreEvent(pre_event);
            this.node_graph.action_state_dict.set(pre_event.id, state);
            this.curr_state = state;
            if (state_type == StateTypes.TERMINATE) this.is_active = false;
            if (this.state_dict.length == 1) this.init_state = state;
            return {
                'state_transit': true, 'new_event': true
            };
        }
    }
    isActive() {
        return this.is_active;
    }

}

class NodeGraph {
    constructor() {
        this.node_list = new Map();
        this.action_state_dict = new ListMap();//action is hash here
        this.max_tree_depth = 5;
        this.curr_id = 0;
    }

    createNode(curr_path, parent_node, node_props, pre_event, time_diff) {
        /* if node doesnt exist then only create a new node.
         * either a new node created or state transition we update 
         * time_diff: time between pre_event and creation of new nodes.
         *return : state_transit:to check if node not created if transition happened with in state
         * new_event: if state transition has not happened ,is state change happened by new event 
         * multiple events can cause same transition as well
         * node can have same state of actions by a different event
         */
        let curr_node = null;
        if (this.node_list.has(curr_path)) {
            curr_node = this.node_list.get(curr_path);
            let status = curr_node.addNewState(node_props.dims, node_props.props, pre_event, StateTypes.TRANSIT);
            status['new_node'] = false;
            return [curr_node, status];
        }
        else {
            curr_node = new Node(this, curr_path, parent_node, node_props.dims, node_props.props, pre_event, this.curr_id);
            this.curr_id += 1;
            if (curr_node.parent != null) curr_node.parent.children.push(curr_node);
            this.node_list.set(curr_path, curr_node);
            return [curr_node, { 'new_node': true, 'state_transit': false, 'new_event': true }];
        }

    }

    terminateNodeState(curr_path,pre_event) {
        if (this.node_list.has(curr_path)) {
            curr_node = this.node_list.get(curr_path);
            let status = curr_node.addNewState(null, null, pre_event, StateTypes.TERMINATE);
        }
        else {
            console.log.info("can't terminte node state as it doesn't exist ");
        }
    }
    updateParentOfNodes(nodes) {
        let valid_nodes = [];
        for (let [node, info] of nodes) {
            let parent_path = node.path.slice(0, node.path.lastIndexOf('/'));
            if (!this.node_list.has(parent_path)) {
                throw "Child Node without parent found some issue " + parent_path;
            }
            if (node.parent == null) continue;
            node.parent = this.node_list.get(parent_path);
            if (node.parent != null) node.depth = node.parent.depth + 1;
            if (node.depth <= this.max_tree_depth) {
                valid_nodes.push([node, info]);
            }
            else {
                console.info('max tree depth reached at ', node.path);
            }
        }
        return valid_nodes;
    }

    domObjToNodes(dom_obj_list, pre_event, time_diff) {
        /*
         * dom_obj_list: multiple nodes can be added to transverse
         recursive loop use stack ,breadth first order.node and its all children
         explored then we go next.
         new Elements are pushed at bottom and we remove elements from top.Node that
         is explored its children will be pushed at bottom.
          create: if new node or state transition is true,for new event no need
          to transverse again..
         */
        let all_nodes = [];
        let stack = dom_obj_list.map(dom => [dom, null]);
        let mutation_list = [];
        while (stack.length) {
            let [dom_node, parent_node] = stack.shift();
            let curr_path = dom_node.path;
            let node_props = dom_node.node;
            mutation_list.push({ 'path': curr_path, 'time_diff': time_diff });
            let [curr_node, node_info] = this.createNode(curr_path, parent_node, node_props, pre_event, time_diff);
            let create = node_info['new_node'] || node_info['state_transit'];
            if (create) {
                all_nodes.push([curr_node, node_info]);
                pre_event.addNextNode(curr_node);
            }
            for (let child of dom_node.child_nodes) {
                stack.push([child, curr_node]);
            }

        }
        pre_event.addMutations(mutation_list);
        return all_nodes;
    }

    updateDefaultListenerOnNode(node) {
        let listeners = MOUSE_DEFAULT_ACTIONS.map(mm => { return { 'type': mm }; });
        node.curr_state.addListenerns(listeners);
    }

    async  updateListenersOnNodes(nodes, page) {
        /*actions are updated to node state
         * */
        let listerner_nodes = [];
        const client = await page.target().createCDPSession();
        for (let [node, info] of nodes) {
            try {
                //this.updateDefaultListenerOnNode(node);
                let path = node.path;
                let exp = "document.evaluate(\'" + path + "\', document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue";
                const { result } = await client.send('Runtime.evaluate', { expression: exp });
                if (result ?.objectId == undefined) {
                    console.error('Failed to evalute exp for ', path);
                    continue;
                }
                const { listeners } = await client.send('DOMDebugger.getEventListeners', { objectId: result.objectId });
                if (listeners.length > 0) {
                    //if transition or new nodes then only make it active
                    if (info['new_node'] || info['state_transit']) {
                        node.curr_state.addListenerns(listeners);
                        listerner_nodes.push([node, info]);
                    }
                }
                //actions should be in sorted order
                node.curr_state.sortActions();
            }
            catch (err) {
                console.log(err.stack);
            }
        };
        return listerner_nodes;
    }

    _backTrace(event) {
        /* trace to parent node from given state
         */
        let queue = [event];
        let curr_event = null;
        while (queue.length) {
            curr_event = queue.shift();
            let curr_state = curr_event.state;
            if (curr_state == null) break;
            if (!curr_state.backTrace()) continue;
            curr_state.pre_events.forEach(ev => {
                queue.push(ev);
                ev.backTrace(curr_event);
            });

        }
        return curr_event;
    }

    _forwardTrace(curr_event) {
        let event_list = [], last_event = null;
        while (curr_event != null) {
            last_event = curr_event;
            if (curr_event.state) curr_event.state.forwardTrace();
            event_list.push(curr_event);
            curr_event = curr_event.forwardTrace();
        }
        return event_list.slice(0, -1);
    }

    getEventTrace(event) {
        /*we can simply add back events to next for trace ,but we try to explore
         *full to top ,expensive but it may give better routes in few cases 
         **/
        let curr_event = this._backTrace(event);
        return this._forwardTrace(curr_event);
    }

    runSyncEvent(event) {
        /*wait for event to do mutation */
        let states = action_state_dict.get(event.id);
        let act = new ActivityRecorder();
        let act_name = 'check_mutation';
        act.startNewActivity(act_name, (item) => {
            if (item['type'] == 'mutation') {
                mutations.push(item);
            }
            else if (item['type'] == 'action') {
                found_actions.push(item);
            }
        });



    }

}

module.exports = {
    NodeGraph: NodeGraph,
    State: State
}